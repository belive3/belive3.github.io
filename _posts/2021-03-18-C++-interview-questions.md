---
title:  "C++面试题"
date:   2021-03-17 11:09:23
categories: [面试]
tags: [C++]
---

## C++面试题

1、某文件中定义的静态全局变量(或称静态外部变量)，其作用域是()---->本文件

2、如何判断一段程序是由C编译的还是C++编译的？

```C++
#ifdef __cplusplus
    cout << "C++"
#else
    cout << "C"
#endif
```

3、C++函数中值的传递方式有？---->值传递、指针传递、引用传递

4、C和C++有什么不同？

- 从机制上：c是面向过程的，C++是面向对象的，提供了类；
- 从使用方向上：c适合要求代码体积小的，效率高的场合，如嵌入式；C++更适合上层的，复杂的；
- c语言是结构化编程语言，C++是面向对象编程语言；

5、'new' in c++ a: operator(运算符)

6、多态的作用？

- 隐藏实现细节，使代码模块化；扩展代码模块，实现代码重用；
- 接口重用：为了类在继承和派生时，保证使用家族中任一类的实例的某一属性的正确调用

7、面向对象的三个基本特征，并简单叙述之？

- 封装：将客观事物抽象成类，对每个类的数据和方法实行保护(private、protected、public)；
- 继承：实现继承、可视继承、接口继承；主要目地是实现代码的复用；
- 多态：使代码模块化，接口复用；

8、main函数执行之前，还会执行什么代码？---->全局对象的构造函数在main函数之前执行

9、内联函数在编译时是否做参数类型检查？---->内联函数要做参数类型检查，这是内联函数跟宏相比的优势

10、变量的指针是指变量的---->地址

11、内存的分配方式有几种？

- 静态存储区域分配；在编译时已经分配好，程序整个运行期间都在；例如全局变量
- 在栈上创建；执行时，函数内局部变量的存储单元可以在栈上创建，函数执行结束后自动释放；
- 从堆上分配;程序运行时用malloc和new申请任意空间，程序员自己负责在何时用free或delete释放内存

12、对于频繁使用的短小函数，在c与C++中的实现方法---->c用宏定义，C++用inline

13、全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？

- 生命周期不同：全局变量随程序的创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，退出就不存在了；
- 使用方式不同：声明全局变量后，程序的各个部分都可以用到，分配在全局
- 数据区；局部变量只能在局部使用，分配在栈区；
- 操作系统和编译器通过在内存的分配位置来知道

14、有了malloc/free为什么还需要new/delete?

- malloc/free 是c/c++的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。malloc/free 无法满足动态对象的要求；对象在创建的时候需要调用构造函数，对象在销毁前需要调用析构函数；

15、如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。怎么处理？ ---->判断指针是否为NULL，如果是则马上用return终止本函数

16、C++是不是类型安全的？---->不是。两个不同类型的指针可以强制转换 如：reinterpret_cast(用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换)

17、如何让判断系统是16位还是32位?---->定义指针p，打印sizeof(p)如果输出4是32位，如果输出2则是16位。

18、c++判断系统是16位还是32位？不能用sizeof()函数

```C++
unsigned int a = ~0;
if(a > 65536)
{
    cout << "32bit" << endl;
}
else
{
    cout << "16bit" << endl;
}
```
19、为什么需要堆，使用堆的原因？----> 只有运行时才知道一个对象需要多少空间；不知道对象的生存周期到底有多长；

20、若数组名作为实参而指针变量作为形参，函数调用实参传给形参的是：数组的一个元素的地址(一般同时需要传递数组的元素个数)

21、为什么数组名作为参数，会改变数组的内容，而其他类型如int却不会改变变量的值？

- 当数组名作为参数时，传递的实际上是地址。而其他类型如int作为参数时，由于函数参数实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值；

22、析构函数和虚函数的用法和作用?---->析构函数时特殊的类成员函数，没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象生命期结束后由系统调用，释放空间；虚函数是C++多态的一种表现，使用虚函数，我们可以灵活的进行绑定，当然是以一定开销为代价。

23、`classA &a = new classB` 如果classA中定义并实现虚函数int func(void),calssB中也实现该函数，那么上述变量a->func()将调用那个类里面的函数？如果int func(void)不是虚函数，又如何？为什么？

- 第一种调的是B的函数。第二种调的是A的函数。原因：虚函数只能借助于指针或者引用来达到多态的效果

24、引用和指针有什么区别？

- 引用需要初始化，指针不必；
- 引用初始化之后不能改变，指针可以改变所指对象；
- 不存在指向空值的引用，但是存在指向空值的指针；
- 使用sizeof看成一个指针的大小是4，而引用则是被引用对象的大小；
- 只能有const指针，不能有引用；

25、不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？

- 程序的可读性变差；
- 太多相同的数字字符串，难保不出错；
- 后期修改比较麻烦容易出错；

26、在C++中有没有纯虚构造函数？---->没有

27、重复多次fclose一个打开过一次的FILE *fp指针会有什么结果？---->导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常。

28、重载(overload)、重写(override，也可以说是覆盖)、重定义的区别？

- 重载是指允许存在多个同名函数，而这些函数的参数不同；
- 重定义是指用于继承、派生类与基类的函数名同名，屏蔽基类的函数；
- 重写是指用于继承、子类重新定义基类虚函数的方法

29、C++里面是不会死所有动作都是main()引起的？----> 不是，例如全局变量的初始化就不是main()引起的

30、C++中virtual与inline的含义分别是什么？

- 在基类成员函数的声明前加上virtual关键字，意味着该成员函数声明为虚函数；特点：希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚函数，这样可以启动联编；
- inline是一种用于实现的关键字，而不是用于声明；特点：目地是为了提高函数的运行效率，代码不能过长，不能包含循环体

31、const关键字》有哪些作用？

- 欲阻止一个变量被修改，可以使用const关键字；在定义时需要初始化；
- 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或者两者同时制定为const；
- 在函数声明中，const可以修饰形参，表明参数值不能被改变；
- 对于类成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
- 对于类的成员函数，有时候必须指定返回值为const类型，使得其返回值不为“左值”；

32、Debug与Release选项的含义？

- Debug通常称为调试版本，它包含调试信息不做任何优化，便于程序员调试
- Release通常称为发行版本，进行了各种优化

33、是不是父类写了一个virtual函数，如果子类覆盖它的函数不加virtual，也能实现多态？

- virtual修饰符会被隐藏继承的，virtual可加可不加；子类的空间里有父类的所有变量(static除外)，同一个函数只存在一个实体(inline除外);
- 子类覆盖它的函数不加virtual，也能实现多态；在子类的空间里有父类的私有变量，但是不能直接访问私有变量；

34、代码`void func(){static int val;}`中，变量val的内存地址位于:---->未初始化数据段

35、在不用第三方参数的情况下，交换两个参数的值:

`a = a + b;b = a - b;a = a - b;`

`a = a ^ b;b = b ^ a;a = a ^ b;`

36、如何打印出当前源文件的文件名以及源文件的当前行号？----> `cout << __FILE__; cout << __LINE__;`__FILE__和__LINE__是系统与定义宏，这种宏是有由编译器定义的；

37、当一个类A中没有任何生命成员变量与成员函数，这时sizeof(A)的值是多少；编译器为什么不让它为零呢？

- 值是1；如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间为零，这时没办法区别A[0]、A[1]....了

38、析构函数可以是纯虚函数吗？---->可以

39、构造函数可以是虚函数吗？----->不可以

40、C++的空类默认产生那些成员函数？

- 缺省构造函数
- 拷贝构造函数
- 虚析构函数
- 赋值运算符
- 取址运算符
- 取址运算符 const

41、在排序方法中，关键码比较次数与记录的初始排序地址无关的是：---->选择排序

42、函数模板与类模板有什么区别？----> 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示调用

43、函数重载，我们靠什么来区分调用的那个函数？靠返回值判断可不可以？---->同名函数不同参数时靠参数来区分；当同名函数仅仅返回值不同，有时可以区分有时不行；

44、所有的运算符都能重载吗？

- 不能改变C++内部数据类型(如int、float等)的运算符
- 不能重载'.'，因为'.'在类中任何成员都有意思
- 不能重载C++运算符号集合中没有的符号,如：'# $ @等'
- 对已存在的运算符重载时不能改变其优先级

45、基类的析构函数不是虚函数，会带来什么问题？---->派生类的析构函数用不上，会造成资源泄漏；

46、介绍一下模板和容器。如何实现？

- 模板是实现重用机制的一种工具，实质就是实现类型参数化，即把类型定义为参数。
- 容器：数组(vector)、队列(deque)、链表(list)、映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

47、容器vector、deque和list的使用区别：

- 若需要随机访问时选择vector;
- 若已知需要存储元素的数目，则选择vector;
- 若需要随机插入/删除(不仅仅在两端),则选择vector;
- 只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector;
- 若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中;
- 当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用

48、深拷贝？浅拷贝？临时对象？

- 深拷贝意味着拷贝了资源和指针，而浅拷贝只是拷贝了指针，没有拷贝资源。这样使得两个指针指向同一份资源，造成对同一份资源析构两次，程序崩溃。
- 临时对象的开销比局部对象小些

49、在类中如何使用const的？---->有时候我们希望某些常量只在类中有效。

50、两个互相独立的类：classA和classB，都各自定义了非静态的公有成员函数PublicFunc()和非静态的私有成员函数PrivateFunc();现在要在classA中增加定义一个成员函数classA::AdditionalPunction(classA a, classB b);则可以在AdditionPunction(classA x, classB y)的实现部分(函数功能体内部)出现的合法的表达最全的是：

- x.PrivateFunc();x.PublicFunc();y.PublicFunc();

51、如何使用return语句的？

- return语句不可返回指向"栈内存"的”指针“或者”引用“。因为该内存在函数体结束时被销毁；
- 要搞清楚返回的究竟是“值”、“指针”还是“引用”；
- 如果函数返回值是一个对象，要考虑return语句的效率；

52、`return String(s1 + s@);`和`String temp(s1 + s2);return temp;`一样吗？

- 这是临时对象的语法，表示“创建一个临时对象并返回它”
- 将发生三件事：首先temp对象被创建，同时完成初始化；然后拷贝构造函数把temp拷贝到保存返回值的外部存储单元中；最后，temp在函数结束时被销毁(调用析构函数)；

53、以下代码有什么问题？`cout << (true?1:"1") << endl;`  ---->三元表达式"? :" 问号后面的两个操作符必须为同一类型；

54、除了基类指针还有什么可以指向派生类的对象？

- 派生类指针
- 智能指针

55、malloc与alloc的区别？

- alloca是向栈申请内存，因此无需释放；
- malloc是向堆申请内存，并且没有初始化内存，因此基本上malloc之后，调用函数memset来初始化这部分的内存空间；

56、声明一个普通的类模板？
```
template <typename T>
class Complex{
public:
    //构造函数
    Complex(T a, T b)
    {
        this->a = a;
        this->b = b;
    }

    //运算符重载
    Complex<T> operator+(Complex &c)
    {
        Complex<T> tmp(this->a+c.a, this->b+c.b);
        return tmp;
    }

private:
    T a;
    T b;
}

int main()
{
    //对象的定义，必须声明模板类型，因为要分配内容
    Complex<int> a(10,20);
    Complex<int> b(20,30);
    Complex<int> c = a + b;

    return 0;
}
```

57、声明函数模板？

```
template<typename T>
int compare(const T& left, const T& right)
{
    if (left < right)
    {
        return -1;
    }

    if (right < left) {
        return 1;
    }

    return 0;
}

compare<int>(1, 2);
```

58、模板的本质？

- 静态编译模板代码
- 调用时将具体类型替代typename
- 实现数据类型参数化

59、static关键字的作用

- 全局静态变量：静态存储区，在整个程序运行期间一直存在，其他文件不可见；
- 局部静态变量：静态存储区，在整个程序运行期间一直存在，只有局部作用域，函数结束时不被销毁，只是不能访问，直到该函数再次被调用，并且值不变；
- 静态函数：静态函数只是在声明他的文件当中可见，不能被其他文件所有；
- 类的静态成员：可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性；
- 类的静态函数：静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员；

60、说一说C++中四种cast转换？

- const_cast：用于将const变量转为非const；
- static_cast：用于各种隐式转换，比如非const转const；
- dynamic_cast：用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转化，只能转指针或引用；
- reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会有问题；

61、介绍智能指针？

- 智能指针主要是用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放申请的内存，从而防止内存泄漏；
- C++11最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用；
- 该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一；
- 只有引用计数为0时，智能指针才会自动释放引用的内存资源；

62、智能指针有没有内存泄漏的问题？

- 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏

63、说一说C++中的四个智能指针：shared_ptr、unique_ptr、weak_ptr、auto_ptr

- auto_ptr(C++98的方案，C++11已经抛弃)：采用所有权模式
```
auto_ptr<string> p1 (new string("auto"))
auto_ptr<string> p2;
p2 = p1;//auto_ptr不会报错
此时p2剥夺了p1的的所有权，但是程序访问p1会报错
```
- unique_ptr：替换auto_ptr
```
unique_ptr<string> p3 (new string("auto"))
unique_ptr<string> p4;
p4 = p3;//unique_ptr会报错
编译器认为p4=p3非法，保证了访问安全
```
- shared_ptr:实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放；
- weak_ptr:是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象；

64、指针和数组的主要区别：

- 指针保存数据的地址；数组保存数据。
- 指针间接访问数据；数组直接访问数据。
- 指针通常用于动态的数据结构；数组通常用于固定数目且数据类型相同的元素。
- 指针通过malloc分配内存，free释放；数组隐式的分配和删除。
- 指针指向匿名数据，操作匿名函数；数组自身即为数据名。

65、野指针是什么？----> 野指针就是指向一个已经删除的对象或者未申请访问受限内存区域的指针

66、函数指针？

- 函数指针是指向函数的指针变量;
- 调用函数和做函数的参数，比如回调函数;
- 

67、如何查看内存泄漏？

- gdb: 将断点打在退出信号上面，再进行bt打印回朔；
- qt: 

## 未完待续






---
title:  "C++面试题"
date:   2021-03-17 11:09:23
categories: [面试]
tags: [C++]
---

## C++面试题

1、某文件中定义的静态全局变量(或称静态外部变量)，其作用域是()---->本文件

2、如何判断一段程序是由C编译的还是C++编译的？

```C++
#ifdef __cplusplus
    cout << "C++"
#else
    cout << "C"
#endif
```

3、C++函数中值的传递方式有？---->值传递、指针传递、引用传递

4、C和C++有什么不同？

- 从机制上：c是面向过程的，C++是面向对象的，提供了类；
- 从使用方向上：c适合要求代码体积小的，效率高的场合，如嵌入式；C++更适合上层的，复杂的；
- c语言是结构化编程语言，C++是面向对象编程语言；

5、'new' in c++ a: operator(运算符)

6、多态的作用？

- 隐藏实现细节，使代码模块化；扩展代码模块，实现代码重用；
- 接口重用：为了类在继承和派生时，保证使用家族中任一类的实例的某一属性的正确调用

7、面向对象的三个基本特征，并简单叙述之？

- 封装：将客观事物抽象成类，对每个类的数据和方法实行保护(private、protected、public)；
- 继承：实现继承、可视继承、接口继承；主要目地是实现代码的复用；
- 多态：使代码模块化，接口复用；

8、main函数执行之前，还会执行什么代码？---->全局对象的构造函数在main函数之前执行

9、内联函数在编译时是否做参数类型检查？---->内联函数要做参数类型检查，这是内联函数跟宏相比的优势

10、变量的指针是指变量的---->地址

11、内存的分配方式有几种？

- 静态存储区域分配；在编译时已经分配好，程序整个运行期间都在；例如全局变量
- 在栈上创建；执行时，函数内局部变量的存储单元可以在栈上创建，函数执行结束后自动释放；
- 从堆上分配;程序运行时用malloc和new申请任意空间，程序员自己负责在何时用free或delete释放内存

12、对于频繁使用的短小函数，在c与C++中的实现方法---->c用宏定义，C++用inline

13、全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？

- 生命周期不同：全局变量随程序的创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，退出就不存在了；
- 使用方式不同：声明全局变量后，程序的各个部分都可以用到，分配在全局
- 数据区；局部变量只能在局部使用，分配在栈区；
- 操作系统和编译器通过在内存的分配位置来知道

14、有了malloc/free为什么还需要new/delete?

- malloc/free 是c/c++的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。malloc/free 无法满足动态对象的要求；对象在创建的时候需要调用构造函数，对象在销毁前需要调用析构函数；

15、如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。怎么处理？ ---->判断指针是否为NULL，如果是则马上用return终止本函数

16、C++是不是类型安全的？---->不是。两个不同类型的指针可以强制转换 如：reinterpret_cast(用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换)

17、如何让判断系统是16位还是32位?---->定义指针p，打印sizeof(p)如果输出4是32位，如果输出2则是16位。

18、c++判断系统是16位还是32位？不能用sizeof()函数

```C++
unsigned int a = ~0;
if(a > 65536)
{
    cout << "32bit" << endl;
}
else
{
    cout << "16bit" << endl;
}
```
19、为什么需要堆，使用堆的原因？----> 只有运行时才知道一个对象需要多少空间；不知道对象的生存周期到底有多长；

20、若数组名作为实参而指针变量作为形参，函数调用实参传给形参的是：数组的一个元素的地址(一般同时需要传递数组的长度)

21、为什么数组名作为参数，会改变数组的内容，而其他类型如int却不会改变变量的值？

- 当数组名作为参数时，传递的实际上是地址。而其他类型如int作为参数时，由于函数参数实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值；

22、析构函数和虚函数的用法和作用?---->析构函数时特殊的类成员函数，没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象生命期结束后由系统调用，释放空间；虚函数是C++多态的一种表现，使用虚函数，我们可以灵活的进行绑定，当然是以一定开销为代价。

23、`classA &a = new classB` 如果classA中定义并实现虚函数int func(void),calssB中也实现该函数，那么上述变量a->func()将调用那个类里面的函数？如果int func(void)不是虚函数，又如何？为什么？

- 第一种调的是B的函数。第二种调的是A的函数。原因：虚函数只能借助于指针或者引用来达到多态的效果

24、引用和指针有什么区别？

- 引用需要初始化，指针不必；
- 引用初始化之后不能改变，指针可以改变所指对象
- 不存在指向空值的引用，但是存在指向空值的指针

25、不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？

- 程序的可读性变差；
- 太多相同的数字字符串，难保不出错；
- 后期修改比较麻烦容易出错；

26、在C++中有没有纯虚构造函数？---->没有

27、重复多次fclose一个打开过一次的FILE *fp指针会有什么结果？---->导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常。

28、重载(overload)、重写(override，也可以说是覆盖)、重定义的区别？

- 重载是指允许存在多个同名函数，而这些函数的参数不同；
- 重定义是指用于继承、派生类与基类的函数名同名，屏蔽基类的函数；
- 重写是指用于继承、子类重新定义基类虚函数的方法

29、C++里面是不会死所有动作都是main()引起的？----> 不是，例如全局变量的初始化就不是main()引起的

30、C++中virtual与inline的含义分别是什么？

- 在基类成员函数的声明前加上virtual关键字，意味着该成员函数声明为虚函数；特点：希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚函数，这样可以启动联编；
- inline是一种用于实现的关键字，而不是用于声明；特点：目地是为了提高函数的运行效率，代码不能过长，不能包含循环体

31、const关键字》有哪些作用？

- 欲阻止一个变量被修改，可以使用const关键字；在定义时需要初始化；
- 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或者两者同时制定为const；
- 在函数声明中，const可以修饰形参，表明参数值不能被改变；
- 对于类成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
- 对于类的成员函数，有时候必须指定返回值为const类型，使得其返回值不为“左值”；

32、Debug与Release选项的含义？

- Debug通常称为调试版本，它包含调试信息不做任何优化，便于程序员调试
- Release通常称为发行版本，进行了各种优化

33、是不是父类写了一个virtual函数，如果子类覆盖它的函数不加virtual，也能实现多态？

- virtual修饰符会被隐藏继承的，virtual可加可不加；子类的空间里有父类的所有变量(static除外)，同一个函数只存在一个实体(inline除外);
- 子类覆盖它的函数不加virtual，也能实现多态；在子类的空间里有父类的私有变量，但是不能直接访问私有变量；

34、代码`void func(){static int val;}`中，变量val的内存地址位于:---->未初始化数据段

35、在不用第三方参数的情况下，交换两个参数的值:

`a = a + b;b = a - b;a = a - b;`

`a = a ^ b;b = b ^ a;a = a ^ b;`

36、如何打印出当前源文件的文件名以及源文件的当前行号？----> `cout << __FILE__; cout << __LINE__;`__FILE__和__LINE__是系统与定义宏，这种宏是有由编译器定义的；

37、当一个类A中没有任何生命成员变量与成员函数，这时sizeof(A)的值是多少；编译器为什么不让它为零呢？

- 值是1；如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间为零，这时没办法区别A[0]、A[1]....了

38、析构函数可以是纯虚函数吗？---->可以

39、构造函数可以是虚函数吗？----->不可以

40、C++的空类默认产生那些成员函数？

- 缺省构造函数
- 拷贝构造函数
- 虚析构函数
- 赋值运算符
- 取址运算符
- 取址运算符 const

41、在排序方法中，关键码比较次数与记录的初始排序地址无关的是：---->选择排序

42、函数模板与类模板有什么区别？----> 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示调用

43、函数重载，我们靠什么来区分调用的那个函数？靠返回值判断可不可以？---->同名函数不同参数时靠参数来区分；当同名函数仅仅返回值不同，有时可以区分有时不行；

44、所有的运算符都能重载吗？

- 不能改变C++内部数据类型(如int、float等)的运算符
- 不能重载'.'，因为'.'在类中任何成员都有意思
- 不能重载C++运算符号集合中没有的符号,如：'# $ @等'
- 对已存在的运算符重载时不能改变其优先级

45、基类的析构函数不是虚函数，会带来什么问题？---->派生类的析构函数用不上，会造成资源泄漏；

46、介绍一下模板和容器。如何实现？

- 模板是实现重用机制的一种工具，实质就是实现类型参数化，即把类型定义为参数。
- 容器：数组(vector)、队列(deque)、链表(list)、映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

47、容器vector、deque和list的使用区别：

- 若需要随机访问时选择vector;
- 若已知需要存储元素的数目，则选择vector;
- 若需要随机插入/删除(不仅仅在两端),则选择vector;
- 只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector;
- 若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中;
- 当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用

## 未完待续





